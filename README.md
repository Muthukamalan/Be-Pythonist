# Setup


# Pre-Requisites
- variables and simple types such as `str` , `bool` , `int`  and `float`  types
- `for` and `while`  loops
- `if`...`else`...  statements
- defining functions (using the `def`  statement)
- writing simple classes using the `class`  keyword and the `__init__`  function
- using simple `lists` , `tuples` , `dictionaries`  and `sets`


#  Content [Deep Dive Functional](https://www.udemy.com/course/python-3-deep-dive-part-1/)

## Basics Review
- [ ] Type Hierarchy
- [ ] Multi-Line Statement and String
- [ ] Variable name
- [ ] Conditionals
- [ ] Functions
- [ ] While
- [ ] Break,Continue and Try
- [ ] For loop
- [ ] Classes

## Variables and Memory
- [ ] Variable and Memory Reference
- [ ] Reference Counting
- [ ] Garbage Collection
- [ ] Dynamic Vs Static Typing
- [ ] Variable Re-Assignment
- [ ] Object Mutability
- [ ] Function Argument and Mutability
- [ ] Shared Reference and Mutability
- [ ] Variable Equality
- [ ] Everytging is an Object
- [ ] Python Optimization: Interning, String Interning, Peephole

## Numeric Types
- [ ] Data Types
- [ ] Operations
- [ ] Constructors and Bases
- [ ] Rational Numbers
- [ ] Floats: Internal Representation
- [ ] Equality Testing
- [ ] Coercing to Integers
- [ ] Rounding
- [ ] Construtors and Contexts
- [ ] Math Operation
- [ ] Decimals
- [ ] Complex Numbers
- [ ] Booleans: Truth Values
- [ ] Booleans: Precedence and Short-circuiting
- [ ] Booleans: Boolean Operation
- [ ] Comparison Operators

## Function Parameters
- [ ] Argument VS Parameter
- [ ] Positional and Keyword Arguments
- [ ] Unpacking Iterables
- [ ] Extended Unpacking
- [ ] *args
- [ ] **kwargs
- [ ] Putting it all Together
- [ ] Appplication: A simple Function Timer
- [ ] Parameter Default

## First-Class Functions
- [ ] Docstrings and Annotations
- [ ] Lambda Expression
- [ ] Lambda and Sorting
- [ ] Randomize an Iterable using Sorted!! `Challenge`
- [ ] Function Introspection
- [ ] Callables
- [ ] Map, Filter, Zip and List Comprehensions
- [ ] Reducing Functions
- [ ] Partial Functions
- [ ] The operatir Module

## Scopes, Closures and Decorators
- [ ] Gloabl and Local Scopes
- [ ] Nonlocal Scopes
- [ ] Closures
- [ ] Closures - Applications 1
- [ ] Closures - Applications 2
- [ ] Decorators
- [ ] Decorators Applications
    -   Timer
    -   Logger
    -   Stacked Decorators
    -   Memoization
- [ ] Decorator Factories
- [ ] Decorder Application: Dispatching

## Tuples as Data Structures and Named Tuples
- [ ] Tuple as Data Struture
- [ ] Named Tuples
- [ ] Named Tuples: Modifying and Extending
- [ ] Named Tuples: DocString and Default Values
- [ ] Applications: 
    -   Returing Multipe Values
    -   Alternative to Dictionaries

## Modules, Packages and Namespaces
- [ ] Modules
- [ ] Imports and Importlib
- [ ] Import Variants and Misconceptions
- [ ] Reloading Modules
- [ ] Using __main__
- [ ] Modules Recap
- [ ] packages
- [ ] Structing
- [ ] Namespace Packges
- [ ] Importing from Zip Archives



# Content [Deep Dive OOPS](https://www.udemy.com/course/python-3-deep-dive-part-4/)

## Classes
- [ ] Objects and Classes
- [ ] Class Attributes
- [ ] Callable Class Attributes
- [ ] Classes are Callables
- [ ] Data Attributes
- [ ] Function Attributes
- [ ] Initializing Class Instances
- [ ] Creating Attributes at Run Time
- [ ] Properties
- [ ] Property Decorators
- [ ] Read-Only and Computed Properties
- [ ] Deleting Properties
- [ ] Some Questions on Property class
- [ ] Class and Static Methods
- [ ] Python Builtin and Standard Types
- [ ] Class Body Scope

## Project 1

## Polymorphism and Special Methods
- [ ] __str__ and __repr__ methods
- [ ] Arithmetic Operators
- [ ] Rich Comparisons
- [ ] Hashing and Equality
- [ ] Booleans
- [ ] Callables
- [ ] __del__ methods
- [ ] __format__ method

## Project 2

## Single Inheritance
- [ ] Single Inheritance
- [ ] Object Class
- [ ] Overriding
- [ ] Extending
- [ ] Delegating
- [ ] Slots
- [ ] Slots and Single Inheritance

## Project 3

## Descriptors
- [ ] Getters and Setters
- [ ] Using as Instance Properties
- [ ] Strong and Weak References
- [ ] Back to Instance Properties
- [ ] __set_name__ method
- [ ] Property Lookup Resolution
- [ ] Properties and Descriptors
- [ ] Application
- [ ] Functions and Descriptors

## Project 4

## Enumeratons
- [ ] Making the case for Enumerations
- [ ] Enumerations 
- [ ] Aliases
- [ ] Customizing/Extending Enums
- [ ] Automatic Values

## Project 5

## Exceptions ( Single Inheritance )
- [ ] Python Exceptions
- [ ] handling Exceptions
- [ ] Raising Exceptions
- [ ] Custom Exceptions

## Project 6

## Metaprogramming
- [ ] Decorators and Descriptors
- [ ] __new__ method
- [ ] How classes are Created
- [ ] Inheriting from type
- [ ] MetaClasses
- [ ] Class Decorators
- [ ] Decorator Classes
- [ ] Metaclass Vs Class Decorator
- [ ] Metaclass Parameters
- [ ] __prepare__ method
- [ ] classes, metaclasses and __call__
- [ ] Metaprogramming Applications
- [ ] Attribute Read Accessors
- [ ] Attribute Write Accessors
- [ ] Accessors